import axios from "axios";
import { call, put, all } from "redux-saga/effects";
import * as appLoaderActions from "../components/common/AppLoader/actions";
import * as appMessageActions from "../components/common/AppMessage/actions";
import * as apiConsoleActions from "../components/common/ApiConsole/actions";
import { isEmpty, has } from "lodash";
import { v4 as uuidv4 } from "uuid";
import { kibanaLogger } from "../utils/kibanaLogger";
import * as DOMPurify from "dompurify";
import Trace from "./NewRelicService";
import * as taggingActions from "../pages/common/tagging/actions";
import * as taggingConstants from "../pages/common/tagging/constants";
import { ERROR } from "../components/RefundExchange/common/Header/ErrorCode";
import logger from "../services/jsNotifier/logger.service";
import { addDateToSession } from "../utils/common_functions";

export const addRequestHeader = (request = {}) => {
  const header = {};
  request.header = { ...(request.header || {}), ...header };
  return request;
};

export const generatee2erequestid = () => {
  let e2erequestid = uuidv4();
  window.e2erequestid = e2erequestid;
  return e2erequestid;
};


export function getVisitorId() {
  let cookies = document?.cookie,
    name = "visitor_id",
    visitor_id = "";
  if (cookies?.length > 0) {
    let c_start = cookies?.indexOf(name + "=");
    if (c_start !== -1) {
      c_start = c_start + name.length + 1;
      let c_end = cookies?.indexOf(";", c_start);
      if (c_end === -1) {
        c_end = cookies?.length;
      }
      visitor_id = cookies?.substring(c_start, c_end);
    }
  }
  console.log("visitor_id==" + visitor_id);
  return visitor_id;
}


const createAxiosService = () => {
  if (!window.e2erequestid)
    window.e2erequestid = generatee2erequestid();


  const channelId = sessionStorage.getItem("channel");
  // Sending channel ID to new relic
  Trace.traceCustomAttribute("channelId", channelId);
  console.log("LOG-DEBUG: createAxiosService -> channelId", channelId);

  return axios.create({
    baseURL: sessionStorage.getItem("APIContext"),
    headers: {
      "Accept": "application/json",
      // "Access-Control-Allow-Origin": "*",
      "Content-type": "application/json",
      //"guisessionId": window.guisessionId,
      "soepagepath": window.location.pathname,
       // do not uncomment below line and merge, it will break PRODUCTION, uncomment only for localhost
      //"x-soe-apikey": "uFWjzl4du5e46whYg73iCGqriX2l62C9",
      "channelId": channelId,
      "x-apikey": "AnUMarA1F1ZlSwhdqF8M6iGVCPzl88Ad",
      "x-nonprod-env": "hivv-nssit1",
      "x-soe-apikey": "uFWjzl4du5e46whYg73iCGqriX2l62C9",
      "e2erequestid": generatee2erequestid()
    },
    /**
     * It is an ask from Vishnu Beemavaram by email
     * to set "withCredentials:true" for all service calls
     * since the ui and service domain are different for INDIRECT channel
     */
    withCredentials: true
  });
};


export const HttpService = createAxiosService();


HttpService.interceptors.request.use(config => {
  // Append the e2erequestid and soepagepath are sent in request
  if (config && config.url && config.url.includes("onevz-msf-apigateway")) {
    const visitorId = sessionStorage.getItem("visitorId") ? sessionStorage.getItem("visitorId") : "";
    const userId = sessionStorage.getItem("userId") ? sessionStorage.getItem("userId") :"";

    Trace.traceCustomAttribute("userId", userId);
    Trace.traceCustomAttribute("visitorId", visitorId);
    Trace.traceCustomAttribute("msfpagepath", window.location.href);
    config.headers = {
      ...config.headers,
      soepagepath: window.location.pathname,
      "Access-Control-Allow-Methods": "GET, HEAD, PATCH, OPTIONS, POST, PUT",
      visitorId: visitorId,
      callType: "msf",
      tabkey: sessionStorage.tabkey,
      userId: userId,
      soeguisubkey:
        sessionStorage.soeguisubkey && sessionStorage.soeguisubkey !== ""
          ? sessionStorage.soeguisubkey
          : window.soeguisubkey,
      soeguivalue: sessionStorage.soeguivalue,
      machineName: sessionStorage.machineName,
      requestTimeStamp: Math.floor(Date.now()),
      // "x-soe-apikey": "uFWjzl4du5e46whYg73iCGqriX2l62C9",
      // "x-apikey": "AnUMarA1F1ZlSwhdqF8M6iGVCPzl88Ad",
      // "x-nonprod-env": "hivv-nssit3"
    };
  } else {
    config.headers = {
      ...config.headers,
      // e2erequestid: generatee2erequestid(), // Should this be generated per request?
      soepagepath: window.location.pathname,
      subkey: window.subkey,
      requestTimeStamp: Math.floor(Date.now()),
      machineName: sessionStorage.getItem("machineName") ? sessionStorage.getItem("machineName") : "",
    };
  }

  if(sessionStorage.getItem("intentType"))
    config.headers.intentType = sessionStorage.getItem("intentType");
    config.headers.flowName = sessionStorage.getItem("intentType");

  return config;
});

export const getCookie = (name) => {
  const pattern = RegExp(`${name}=.[^;]*`);
  const matched = document?.cookie?.match(pattern);
  if (matched) {
    const cookie = matched[0] && matched[0].split("=");
    return cookie[1];
  }
  return "";
};

export const setCookie = (cookieName, value) => {
  document.cookie = `${cookieName}=${value};path=/`;
};

const kibana_regex = new RegExp("jsNotifyAsDynamic", "i");

HttpService.interceptors.request.use((req) => {
  const request = req;

  // Regex to select what call uses the NR services
  if (!kibana_regex.test(request.url)){
    Trace.traceStartInteraction();
  }

  // add header X-XSRF-TOKEN for only payment APIs
  const paymentRegex = new RegExp("/paymentservice/");
  if (req.url.search(paymentRegex) !== -1) {
    request.headers["X-XSRF-TOKEN"] = getCookie("xsrf-token");
    request.withCredentials = true; // XSRF-TOKEN cookie should be sent in request as well
  }
  if(window.location.hostname.includes("localhost")){
    
   request.headers["sso_jwt"] = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiJNQ0YiLCJ1aWQiOiIzMTUzNDUyMTc3cmVnVG9vbCIsImdpdmVuTmFtZSI6IkxlYm93c2tpIiwiaXNzIjoiaHR0cHM6Ly9zc28tbnAuZWJpei52ZXJpem9uLmNvbSIsImV4cCI6MTcyMzA5MjI0Miwidnp3QWNjb3VudE51bWJlciI6IjA3MjUzMjM5NDYwMDAwMDEiLCJpYXQiOjE3MjMwODg2NDJ9.QdxeqlFKuGajq_H4btFwDhDzMFcV0OlXgJGBI3jhefFbnguUP4k4OpAPa2Wteoz3JRgsGB4NERBsphnopX7hvLOrs-i_s3Y7oVYxd6t2ShwETDjuBdyyYcIqZA8TW_Cy8lyEa7BPlFn8qRko-I3OlbP3RygHLpuwHq1MCanrYIbAtxWt6Xc5udYBzvrhjOaVUk1fb5rf48RLOI4qxy-BcKr1soK8rVgTlz3D1rc6eXZYaIS3y-ZH0xLrd163A2_oyiKqPQd13U6Nv3-aVt1qgfFiHbY39xXR28TvEKhI8iGqQfLwMZX_g5RWAcQyJHExRWdqcRWxVvxaWv4kn4pSnA";
    request.headers["assisted_ig_session"] = sessionStorage.getItem("assisted_ig_session");
    request.headers["soeguisubkey"] = "ca65cfaf-5883-414f-9fb2-2517eaa5dfd4";
    request.headers["soeguivalue"] = "eyJhbGciOiJSUzI1NiJ9.eyJyZWdObyI6IjAxIiwicmVwUm9sZSI6IlBPU1NZU1RTVCIsInBvc1ZlcnNpb24iOiIyLjAiLCJjaGFubmVsIjoiT01OSS1SRVRBSUwiLCJtYXZlcmlja0xvY2F0aW9uIjpmYWxzZSwiY3JlZGl0QXBwTnVtIjoiNDEzMjgwMTE0IiwiZW1haWxJZCI6IiIsIk9SREVSTE9DIjoiMDAyNjMwMSIsIkhPTUVMT0MiOiIwMDI2MzAxIiwibG9nZ2VkSW5Vc2VyIjoiS1VNQUdPMiIsImN1c3RvbWVyVHlwZSI6Ik4iLCJjYWxsUmVhc29uIjoiQ29uc3VtZXIiLCJtdG4iOiIiLCJhY2NvdW50TnVtYmVyIjoiIiwicmVwSWQiOiJFTkMiLCJpc0hvbWVTYWxlcyI6ImZhbHNlIiwicmVhc29uRm9yVmlzaXQiOiJDb25zdW1lciIsInF1aWNrVmlldyI6eyJwZW5kaW5nT3JkZXJDb3VudCI6IjAiLCJlbGlnaWJsZUxpbmVDb3VudCI6IjAiLCJwYXN0RHVlIjoiMCIsImJ0YUFtb3VudCI6IjAiLCJkcEVsaWdpYmlsaXR5IjoiTm90IFZlcmlmaWVkIiwidG1wbWRFbGlnaWJsZSI6ZmFsc2UsInRhaEVsaWdpYmxlIjoiVEFIIEVsaWdpYmxlIn0sInZlcmlmaWVkTmFtZSI6ImRmZWQgZXJlIiwiaG9tZVNhbGVzQWRkcmVzcyI6IntcInN0cmVldE51bWJlclwiOlwiMVwiLFwic3RyZWV0TmFtZVwiOlwiVkVSSVpPTlwiLFwic3RyZWV0VHlwZVwiOlwiV0FZXCIsXCJzdHJlZXRBZGRyZXNzXCI6XCIxIFZFUklaT04gV0FZIFwiLFwic3RhdGVcIjpcIk5KXCIsXCJjaXR5XCI6XCJCQVNLSU5HIFJJREdFXCIsXCJ6aXBDb2RlXCI6XCIwNzkyMFwiLFwiemlwQ29kZVBsdXM0XCI6XCIxMDI1XCIsXCJ1bml0VHlwZVwiOlwiXCIsXCJhcHROdW1iZXJcIjpcIlwiLFwibXVsdGlwbGVBZGRyZXNzQ29uZmlybVwiOmZhbHNlLFwibGF0aXR1ZGVcIjpcIlwiLFwibG9uZ2l0dWRlXCI6XCJcIixcInZlbmRvcktleVwiOlwiXCIsXCJldmVudENvcnJlbGF0aW9uSWRcIjpcIjA3OTIwXzE3MjI1MDIxMjMxMTJfNDc3XCIsXCJsb2NhdGlvblR5cGVcIjpcIlwiLFwiQ0JhbmRTa3VcIjpcIkFTSy1OQ1ExMzM4RkFcIixcInByaW9yUXVhbGlmaWNhdGlvblwiOntcImZpdmVHSG9tZVF1YWxpZmllZFwiOmZhbHNlLFwiTFRFUXVhbGlmaWVkXCI6dHJ1ZSxcImNiYW5kUXVhbGlmaWVkXCI6dHJ1ZSxcInRhbmdsZXdvb2RRdWFsaWZpZWRcIjpmYWxzZX0sXCJsZWFkVHlwZVwiOlwiXCIsXCJpc0J1eWVyc1JpZ2h0VG9DYW5jZWxcIjpcIllcIixcIkxURVF1YWxpZmllZFwiOmZhbHNlLFwiY0JhbmRRdWFsaWZpZWRcIjp0cnVlLFwiZml2ZUdIb21lUXVhbGlmaWVkXCI6ZmFsc2UsXCJidW5kbGVzXCI6W119IiwiaWF0IjoxNzIyNTAyMTI4fQ.Xhv_wePcxzEVmwotPGauFC8uKc7_bxxZgQFmHACtsnfN84MJyV9yzA9WKPeqM7CjnnyoxTDQi4QF4DI7tP7U9_kZJeWJIdvV7XXKx6Wtq0LmHKCOHmCZIqG2UUeHxN73skfp_MkOhaHkm385bjl36SN8IFoX37azAKR2jXlBeVB1HE5NGZFIEfs9JrQFyIU_DFvTMAoNJ8-blXrP5zf1PJE-p61I8RlwT-o7hJYRSgUw60HJxlk9bJ-1cj5si_gs4xV2W5OrScV9GUHjH4B66rkiN_YG_2zlTEIrikuXJu5sF3nTozoZAg2ZuxWQtJ32Oo1dBZCQYB3om4a5OYlDSg";
  }
  let nsasoeguisubkey =  sessionStorage.getItem("nsasoeguisubkey");
  let nsasoeguivalue =  sessionStorage.getItem("nsasoeguivalue");

  if(nsasoeguisubkey && nsasoeguivalue)
  {
    request.headers["soeguivalue"] = nsasoeguivalue;
    request.headers["soeguisubkey"] = nsasoeguisubkey;
  }
  
  return request;
});

HttpService.interceptors.response.use(response => {
  // Logic for the API console, needs to be refactored, should be in one method
  let urlPartitions = response && response.config && response.config.url ? response.config.url.split("/") : "";
  let e2erequestid = !sessionStorage.getItem("enableMock") ? response.headers["e2erequestid"] ? response.headers["e2erequestid"] : "" : "";
  if (urlPartitions) {
    let path = urlPartitions[urlPartitions.length - 2] || "";
    let endPoint = urlPartitions[urlPartitions.length - 1] || "";
    let status = response.status || "";

    let payload = {
      status: status,
      endPoint: endPoint,
      path: path,
      e2erequestid: e2erequestid
    };
    window.store.dispatch(apiConsoleActions.getApiConsoleData(payload));
    /** Adding Date to session to be used as client's time for preorder start time*/
    addDateToSession(response);
  }
  // ApiConsole logic end
  if (response.data && response.data.goToUrl !== undefined) {
    window.location.href = DOMPurify.sanitize(`${decodeURIComponent(response.data.goToUrl)}&TARGET=$SM$${window.location.href}`);
  }

  if (response && response.config && !kibana_regex.test(response.config.url)){
    Trace.traceSaveInteraction();
  }
  let flowName = response?.data?.serviceBody?.serviceResponse?.context?.cartInfo?.flow;
  let rcFlowname = response?.data?.data?.cart?.flow ;
  console.log('Flowname from response -- ',flowName ,'rcFlowname----',rcFlowname ,response , response.config.url );
  if (flowName) {
    console.log(' API flowname ',flowName);
    window.store.dispatch(apiConsoleActions.getFlowName({
      flowName: flowName
    }));
  }else if(rcFlowname){
    console.log('RC flowname ',rcFlowname);
    window.store.dispatch(apiConsoleActions.getFlowName({
      flowName: rcFlowname
    }));
  }
  return response;
}, error => {
  // console.log("error at interceptors", error);
  // Logic for the API console, needs to be refactored, should be in one method
  let urlPartitions = error && error.config && error.config.url ? error.config.url.split("/") : "";
  let e2erequestid = error && error.response && error.response.headers["e2erequestid"] ? error.response.headers["e2erequestid"] : "";
  if (urlPartitions) {
    let path = urlPartitions[urlPartitions.length - 2] || "";
    let endPoint = urlPartitions[urlPartitions.length - 1] || "";
    let errorResp = error && error.response || "";
    let status = error && error.response && error.response.status ? error.response.status : "";

    let payload = {
      status: status,
      endPoint: endPoint,
      path: path,
      e2erequestid: e2erequestid,
      errorResp: errorResp
    };
    if (status === "" && e2erequestid === "" && endPoint !== "jsNotifyAsDynamic" && endPoint !== "loginV2") {
      logger.warningNetwork(payload);
    }
    window.store.dispatch(apiConsoleActions.getApiConsoleData(payload));
  }
  // ApiConsole logic end
  // Checking for errors, kibana url. Only the APIs, other than Kibana that has errors will be logged to kibana
  if (error && error.config && error.config.headers && !kibana_regex.test(error.config.url)) {
    error.config.headers.responseTimeStamp = Math.floor(Date.now());
    const responseDuration = error.config.headers.responseTimeStamp - error.config.headers.requestTimeStamp;
    logErrToKibana(error, responseDuration, e2erequestid);
  }

  if (error && error.config && !kibana_regex.test(error.config.url)){
    Trace.traceSaveInteraction();
  }

  window.store.dispatch(taggingActions.invokeTagging({
    pagename: taggingConstants.ERROR_REPORT,
    error
  }));

  throw error;
});


const enableHTTPServiceLogs = sessionStorage.getItem("enableHTTPServiceLogs") || false;

export function parseErrorMessages(error) {
  let messages;
  //temporary : removing JS errors changes because its causing empty green banner messages on multiple pages.
  //  Please check empty green banner condition while getting rid of JS Errors
  const jsErrors = has(error, "message") ? [error.message] : [];
  const apiErrors = has(error, "response.data.errors") ? error.response.data.errors : [];

  //const errorList = jsErrors.concat(apiErrors);
  const errorList = apiErrors;

  enableHTTPServiceLogs && console.log("LOG-DEBUG: parseErrorMessages -> errorList", errorList);
  if (error && !isEmpty(errorList)) {
    const isRfexFlow = sessionStorage.getItem("refundexchange");
    if(isRfexFlow){
      messages = errorList.map(error => {
        if(error.id && ERROR[error.id]){
          if(error.id === "3217" && error.message.includes('Error msg from lineValidationOrderService:')){
            let newMsg = error.message.replace('Error msg from lineValidationOrderService:' ,'');
            newMsg = newMsg.replace('PP','BC');
            return newMsg;
          }
          return ERROR[error.id];
        }else if(error.message){
          if(error.name === "BLIND_INVALID_MTN"){
            return null;
          }
          return error.message;
        }else{
          return error;
        }
      }).join("<br />");
    }else{
       messages = errorList.map(error => {
        if(!error.message
          && error?.details?.[0]?.issue){
          error.message=error.details[0].issue;
        } else if (!error.message) {
          error.message="Something went wrong, please try again.";
        }
        return error.message ? error.message : error }).join("<br />");
    }    
  }
  enableHTTPServiceLogs && console.log("LOG-DEBUG: parseErrorMessages -> messages", messages);
  return messages;
}
export function logErrToKibana(error, responseDuration = 0, e2erequestid) {
  const { data } = error && error.response ? error.response : {};
  const { errors } = error && error.response && error.response.data ? error.response.data : [];
  //let serverDuration = responseDuration;
  //let networkDuration = responseDuration;
  if (errors && errors.length > 0 &&
        !(Object.entries(data.errors[0]).length === 0 &&
            data.errors[0].constructor === Object)) {
    const log =
        {
            messageType: "ERROR",
            eventType: "FeError",
            subEventType: "FeErrorS",
            pageUrl: window.location.href,
            serviceUrl: error && error.config && error.config.url? error.config.url :'',
            method: error.config.method,
            errorMessage: errors[0].message,
            cookie: getVisitorId(),
            e2erequestid: e2erequestid ? e2erequestid : "",
            loggerMessage:
            {
              message: errors[0].message,
              loglevel: errors[0].severity,
              //serverDuration: error.duration ? error.duration : 0,
              responseDuration: responseDuration,
              //networkDuration: networkDuration,
              userAgent: navigator.userAgent,
              pageTitle: document.title,
              host: window.location.host,
              stackTrace: error.stack
            }
        };
    kibanaLogger(log);
  }
}
/**
 * Base method which is called for all API calls.
 * @param {String} method Request Method ( GET|POST|PUT etc )
 * @param {String} url Request URL
 * @param {Object} [request] Request body for the API call
 * @param {Function} [successCallback] Success callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Function} [errorCallback] Error callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Object} [opts] Additional options for configuring the request
 *                      - showLoading -> default: true => Determines if loading shown before and after the request
 *                      - parseResponse -> default: false => Determines if response should be extracted from resp.payload.data
 *                      - showErrorBanner -> default: true => Determines if an app message with the API error should be displayed
 *                      - timeout -> default: 60000ms => Determines after what time the API returns a failure
 *                      - baseURL -> default: empty => Allows customization of the baseURL
 *                      - closeLoadingOnSuccess -> default: false => Stops the loading once success response is done. Wont wait for events inside successHandle to be completed
 */
function* doApiCall(method, url, request, successCallback, errorCallback, opts = {}) {
  enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> method", method);
  enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> url", url);
  const { showLoading = true, parseResponse = false, showErrorBanner = true, timeout = 60000, baseURL, closeLoadingOnSuccess = false, headers, withCredentials, appMessageWithTimer = true } = opts;


  const axiosOptions = { baseURL, timeout, headers, withCredentials };
  try {
    if (showLoading) yield put(appLoaderActions.show());
    let res;
    switch (method) {
      case "GET":
        res = yield call(() => HttpService.get(url, axiosOptions), null);
        break;
      case "POST":
        res = yield call(() => HttpService.post(url, request, axiosOptions), null);
        break;
      case "PUT":
      case "DELETE":
      case "PATCH":
      case "HEAD":
        // TODO: Implement if needed
        break;
      default:
        console.warn("LOG-DEBUG: function*doApiCall -> Incorrect use of doApiCall");
        break;
    }
    const response = parseResponse ? res.data.payload : res;
    enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> response", url, response);
    if (closeLoadingOnSuccess) yield put(appLoaderActions.hide());
    if (successCallback) yield successCallback(response);
  } catch (error) {
    // logErrToKibana(error);
    enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> error", url, error);
    if (closeLoadingOnSuccess) yield put(appLoaderActions.hide());
    if (showErrorBanner && parseErrorMessages(error)) yield put(appMessageActions.addAppMessage(parseErrorMessages(error), "error",true,appMessageWithTimer,true));
    if (errorCallback) yield errorCallback(error);
  } finally {
    enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> finally", url);
    if (showLoading && !closeLoadingOnSuccess) yield put(appLoaderActions.hide());
  }
}

/**
 * Wrapper method for making GET calls
 * @param {String} url Request URL
 * @param {Function} [successCallback] Success callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Function} [errorCallback] Error callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Object} [opts] Additional options for configuring the request
 *                      - showLoading -> default: true => Determines if loading shown before and after the request
 *                      - parseResponse -> default: false => Determines if response should be extracted from resp.payload.data
 *                      - showErrorBanner -> default: true => Determines if an app message with the API error should be displayed
 *                      - timeout -> default: 60000ms => Determines after what time the API returns a failure
 *                      - baseURL -> default: empty => Allows customization of the baseURL
 */
export function* doGet(url, successCallback, errorCallback, opts) {
  yield doApiCall("GET", url, null, successCallback, errorCallback, opts);
}

/**
 * Wrapper method for making POST calls
 * @param {String} url Request URL
 * @param {Object} request Request body for the API call
 * @param {Function} [successCallback] Success callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Function} [errorCallback] Error callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Object} [opts] Additional options for configuring the request
 *                      - showLoading -> default: true => Determines if loading shown before and after the request
 *                      - parseResponse -> default: false => Determines if response should be extracted from resp.payload.data
 *                      - showErrorBanner -> default: true => Determines if an app message with the API error should be displayed
 *                      - timeout -> default: 60000ms => Determines after what time the API returns a failure
 *                      - baseURL -> default: empty => Allows customization of the baseURL
 */
export function* doPost(url, request, successCallback, errorCallback, opts = {}) {
  if (request !== null && request != "" && typeof(request) === "object") {
    yield doApiCall("POST", url, request, successCallback, errorCallback, opts);
  }else{
    console.warn("LOG-DEBUG: function*doApiCall -> request payload is invalid");
    yield put(appMessageActions.addAppMessage("invalid request","error",true,true,true));    
  }  
}


export class AxiosCancelToken {
  constructor() {
    this.cancelTokensList = new Map();
  }

  create(key) {
    return {
      cancelToken: new axios.CancelToken(c => this.cancelTokensList.set(key, c))
    };
  }

  cancel(key, reason) {
    let token = this.cancelTokensList.get(key);
    token && token(reason);
  }

  cancelAll() {
    [...this.cancelTokensList].forEach(([key, token]) => token && token());
  }
}
