import React from 'react';
import { screen, render, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter as Router } from 'react-router-dom';
import SelfCalendarVds from '../../../components/Web/AppointmentScheduleRedesign/SelfCalenderVds';
import { store } from '../../../configureStore';
import { Constants } from './SelfCalendarVds/Constants';
import { mockFuncProps, appointmentProps, appointmentErrorProps, nextProps } from './SelfCalendarVds/TestData';
import { DummyFormattedDates, spyFuncOn, spyFuncutilOn, spyRedirectOn } from '../Common/jestCommon';

describe('Test cases for SelfCalendarVds', () => {
  // let today = new Date();

  // // Subtract 7 days from today's date
  // let sevenDaysAgo = new Date(today);
  // sevenDaysAgo.setDate(today.getDate() - 7);

  // // Format the date to "MM/DD/YYYY"
  // let formattedDatetype1 =
  //   (sevenDaysAgo.getMonth() + 1).toString().padStart(2, '0') +
  //   '/' +
  //   sevenDaysAgo.getDate().toString().padStart(2, '0') +
  //   '/' +
  //   sevenDaysAgo.getFullYear();

  // // Format the date to format "Tuesday, July 15, 2024"
  // let formattedDateType2 =
  //   weekdays[sevenDaysAgo.getDay()] + ', ' + months[sevenDaysAgo.getMonth()] + ' ' + sevenDaysAgo.getDate() + ', ' + sevenDaysAgo.getFullYear();
  // appointmentProps.cartDetails.shippingDetails.deliveryDate = formattedDatetype1;
  // let formattedDateType3 = months[sevenDaysAgo.getMonth()] + ' ' + sevenDaysAgo.getFullYear();

  test('render without crashing', () => {
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} />
      </Provider>,
    );
  });

  test('Check for heading and subheading', () => {
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const title = screen.getByText(Constants.heading);
    const subheading = screen.getByText(Constants.subHeading);
    expect(title).toBeInTheDocument();
    expect(subheading).toBeInTheDocument();
  });

  test('Check for target heading and target subheading', () => {
    const monthYearCaption = window.document.createElement('caption');
    monthYearCaption.setAttribute('class', 'DayPicker-Caption ');
    window.document.body.appendChild(monthYearCaption);

    const objTo = document.getElementsByClassName('DayPicker-Caption');
    const monthYearCaptionDiv = window.document.createElement('div');
    monthYearCaptionDiv.setAttribute('id', 'DayPicker-Caption-id');
    objTo[0].appendChild(monthYearCaptionDiv);

    const prevMonthArrow = window.document.createElement('button');
    prevMonthArrow.setAttribute('class', 'DayPicker-NavButton--prev');
    window.document.body.appendChild(prevMonthArrow);

    const nextMonthArrow = window.document.createElement('button');
    nextMonthArrow.setAttribute('class', 'DayPicker-NavButton--next');
    window.document.body.appendChild(nextMonthArrow);

    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const heading = screen.getByText(Constants.targetHeading);
    const subheading = screen.getByText(Constants.targetSubHeading);
    fireEvent.focus(monthYearCaptionDiv, { target: { innerText: 'caption_div' } });
    expect(heading).toBeInTheDocument();
    expect(subheading).toBeInTheDocument();
  });

  test('Check for error Notification text from props', () => {
    render(
      <Router>
        <Provider store={store}>
          <SelfCalendarVds {...mockFuncProps} {...appointmentErrorProps} api_fail_text={Constants.apiError} />
        </Provider>
      </Router>,
    );
    const notification = screen.getByRole(Constants.roleAlert);
    expect(notification).toBeInTheDocument();
    expect(notification).toHaveTextContent(Constants.apiError);
  });

  test('Check for error Notification text from props', () => {
    spyFuncutilOn(Constants.getItemFromStoreFunc, Constants.setTrueStr);
    render(
      <Router>
        <Provider store={store}>
          <SelfCalendarVds {...mockFuncProps} {...appointmentErrorProps} />
        </Provider>
      </Router>,
    );
    const notification = screen.getByRole(Constants.roleAlert);
    expect(notification).toBeInTheDocument();
    expect(notification).toHaveTextContent(Constants.optNotificationError);
  });

  test('Check for cancellation heading and text', () => {
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const cancellationHead = screen.getByText(Constants.selfCancellationHead);
    const cancellationSubHead = screen.getByText(Constants.selfCancellationSubHead);
    expect(cancellationHead).toBeInTheDocument();
    expect(cancellationSubHead).toBeInTheDocument();
  });

  test('Check for policy text and checkbox', () => {
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const policyText = screen.getByText(Constants.policy);
    const Agreementbox = screen.getByTestId(Constants.checkBoxId);
    expect(policyText).toBeInTheDocument();
    expect(Agreementbox).toBeInTheDocument();
    expect(Agreementbox).not.toBeChecked();
  });

  test('Check for Complete order button not visible initially', () => {
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const completeOrder = screen.queryByRole(Constants.roleButton, { name: Constants.completeOrderBtn });
    expect(completeOrder).toBeNull();
  });

  test('Check for calendar to be visible', () => {
    const { formattedDatetype1, formattedDateType2, formattedDateType3 } = DummyFormattedDates();
    appointmentProps.cartDetails.shippingDetails.deliveryDate = formattedDatetype1;
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const monthYear = screen.getByText(formattedDateType3);
    expect(monthYear).toBeInTheDocument();
  });
  test('Check for day 15 Feb to be selected', () => {
    const { formattedDatetype1, formattedDateType2, formattedDateType3 } = DummyFormattedDates();
    appointmentProps.cartDetails.shippingDetails.deliveryDate = formattedDatetype1;
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const date15 = screen.getByRole(Constants.roleButton, { name: formattedDateType2 });
    expect(date15).toBeInTheDocument();
    expect(date15).toBeEnabled();
    fireEvent.click(date15);
    expect(date15).toHaveClass(Constants.activeClass);
  });

  test('Check for enabled Submit order btn & click on it for NSE', () => {
    const { formattedDatetype1, formattedDateType2, formattedDateType3 } = DummyFormattedDates();
    appointmentProps.cartDetails.shippingDetails.deliveryDate = formattedDatetype1;
    spyFuncutilOn(Constants.getItemFromStoreFunc, Constants.setFalseStr);
    spyFuncOn(Constants.getSessionFunc, Constants.setY);
    spyFuncOn(Constants.getAPPIDFunc, Constants.NSE);
    spyRedirectOn(Constants.goToProcessStepFunc, Constants.setNull);
    const { rerender } = render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const date16 = screen.getByRole(Constants.roleButton, { name: formattedDateType2 });
    expect(date16).toBeInTheDocument();
    expect(date16).toBeEnabled();
    fireEvent.click(date16);
    const Agreementbox = screen.getByTestId(Constants.checkBoxId);
    expect(Agreementbox).toBeInTheDocument();
    expect(Agreementbox).not.toBeChecked();
    fireEvent.click(Agreementbox);
    // expect(Agreementbox).not.toBeChecked();
    const completeOrder = screen.queryByRole(Constants.roleButton, { name: Constants.completeOrderBtn });
    expect(completeOrder).toBeInTheDocument();
    expect(completeOrder).toBeEnabled();
    fireEvent.click(completeOrder);
    rerender(
      <Provider store={store}>
        <SelfCalendarVds {...nextProps} {...appointmentProps} />
      </Provider>,
    );
  });

  test('Check for enabled Submit order btn & click on it for AAL', () => {
    const { formattedDatetype1, formattedDateType2, formattedDateType3 } = DummyFormattedDates();
    appointmentProps.cartDetails.shippingDetails.deliveryDate = formattedDatetype1;
    spyFuncutilOn(Constants.getItemFromStoreFunc, Constants.setFalseStr);
    spyFuncOn(Constants.getSessionFunc, Constants.setY);
    spyFuncOn(Constants.getAPPIDFunc, Constants.AAL);
    spyRedirectOn(Constants.goToProcessStepFunc, Constants.setNull);
    const { rerender } = render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} {...appointmentProps} />
      </Provider>,
    );
    const date16 = screen.getByRole(Constants.roleButton, { name: formattedDateType2 });
    expect(date16).toBeInTheDocument();
    fireEvent.click(date16);
    const Agreementbox = screen.getByTestId(Constants.checkBoxId);
    fireEvent.click(Agreementbox);
    const completeOrder = screen.queryByRole(Constants.roleButton, { name: Constants.completeOrderBtn });
    expect(completeOrder).toBeEnabled();
    fireEvent.click(completeOrder);
    rerender(
      <Provider store={store}>
        <SelfCalendarVds {...nextProps} {...appointmentProps} />
      </Provider>,
    );
  });

  test('Check for learnMoreClick function is called ot not on click anchor element', () => {
    spyFuncOn(Constants.viewport, 'mfapp');
    render(
      <Router>
        <Provider store={store}>
          <SelfCalendarVds {...mockFuncProps} {...appointmentErrorProps} />
        </Provider>
      </Router>,
    );
    const learnMoreLink = screen.getByText('learn more here.');
    fireEvent.click(learnMoreLink);
  });

  test('render isPreorder', () => {
    spyFuncOn('isPreorder', true);
    render(
      <Provider store={store}>
        <SelfCalendarVds {...mockFuncProps} />
      </Provider>,
    );
  });
});
