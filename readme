import axios from "axios";
import { call, put, all } from "redux-saga/effects";
import * as appLoaderActions from "../components/common/AppLoader/actions";
import * as appMessageActions from "../components/common/AppMessage/actions";
import * as apiConsoleActions from "../components/common/ApiConsole/actions";
import { isEmpty, has } from "lodash";
import { v4 as uuidv4 } from "uuid";
import { kibanaLogger } from "../utils/kibanaLogger";
import * as DOMPurify from "dompurify";
import Trace from "./NewRelicService";
import * as taggingActions from "../pages/common/tagging/actions";
import * as taggingConstants from "../pages/common/tagging/constants";
import { ERROR } from "../components/RefundExchange/common/Header/ErrorCode";
import logger from "../services/jsNotifier/logger.service";
import { addDateToSession } from "../utils/common_functions";

export const addRequestHeader = (request = {}) => {
  const header = {};
  request.header = { ...(request.header || {}), ...header };
  return request;
};

export const generatee2erequestid = () => {
  let e2erequestid = uuidv4();
  window.e2erequestid = e2erequestid;
  return e2erequestid;
};


export function getVisitorId() {
  let cookies = document?.cookie,
    name = "visitor_id",
    visitor_id = "";
  if (cookies?.length > 0) {
    let c_start = cookies?.indexOf(name + "=");
    if (c_start !== -1) {
      c_start = c_start + name.length + 1;
      let c_end = cookies?.indexOf(";", c_start);
      if (c_end === -1) {
        c_end = cookies?.length;
      }
      visitor_id = cookies?.substring(c_start, c_end);
    }
  }
  console.log("visitor_id==" + visitor_id);
  return visitor_id;
}


const createAxiosService = () => {
  if (!window.e2erequestid)
    window.e2erequestid = generatee2erequestid();


  const channelId = sessionStorage.getItem("channel");
  // Sending channel ID to new relic
  Trace.traceCustomAttribute("channelId", channelId);
  console.log("LOG-DEBUG: createAxiosService -> channelId", channelId);

  return axios.create({
    baseURL: sessionStorage.getItem("APIContext"),
    headers: {
      "Accept": "application/json",
      // "Access-Control-Allow-Origin": "*",
      "Content-type": "application/json",
      //"guisessionId": window.guisessionId,
      "soepagepath": window.location.pathname,
       // do not uncomment below line and merge, it will break PRODUCTION, uncomment only for localhost
      //"x-soe-apikey": "uFWjzl4du5e46whYg73iCGqriX2l62C9",
      "channelId": channelId,
      "x-apikey": "AnUMarA1F1ZlSwhdqF8M6iGVCPzl88Ad",
      "x-nonprod-env": "hivv-nssit1",
      "x-soe-apikey": "uFWjzl4du5e46whYg73iCGqriX2l62C9",
      "e2erequestid": generatee2erequestid()
    },
    /**
     * It is an ask from Vishnu Beemavaram by email
     * to set "withCredentials:true" for all service calls
     * since the ui and service domain are different for INDIRECT channel
     */
    withCredentials: true
  });
};


export const HttpService = createAxiosService();


HttpService.interceptors.request.use(config => {
  // Append the e2erequestid and soepagepath are sent in request
  config.headers = {
    ...config.headers,
    e2erequestid: generatee2erequestid(), // Should this be generated per request?
    soepagepath: window.location.pathname,
    subkey: window.subkey,
    requestTimeStamp: Math.floor(Date.now()),
    machineName: sessionStorage.getItem("machineName") ? sessionStorage.getItem("machineName") : "",
  };

  if(sessionStorage.getItem("intentType"))
    config.headers.intentType = sessionStorage.getItem("intentType");
    config.headers.flowName = sessionStorage.getItem("intentType");

  return config;
});

export const getCookie = (name) => {
  const pattern = RegExp(`${name}=.[^;]*`);
  const matched = document?.cookie?.match(pattern);
  if (matched) {
    const cookie = matched[0] && matched[0].split("=");
    return cookie[1];
  }
  return "";
};

export const setCookie = (cookieName, value) => {
  document.cookie = `${cookieName}=${value};path=/`;
};

const kibana_regex = new RegExp("jsNotifyAsDynamic", "i");

HttpService.interceptors.request.use((req) => {
  const request = req;

  // Regex to select what call uses the NR services
  if (!kibana_regex.test(request.url)){
    Trace.traceStartInteraction();
  }

  // add header X-XSRF-TOKEN for only payment APIs
  const paymentRegex = new RegExp("/paymentservice/");
  if (req.url.search(paymentRegex) !== -1) {
    request.headers["X-XSRF-TOKEN"] = getCookie("xsrf-token");
    request.withCredentials = true; // XSRF-TOKEN cookie should be sent in request as well
  }
  if(window.location.hostname.includes("localhost")){
    request.headers["sso_jwt"] = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiJNQ0YiLCJ1aWQiOiIzMTUzNDUyMTc3cmVnVG9vbCIsImdpdmVuTmFtZSI6IkxlYm93c2tpIiwiaXNzIjoiaHR0cHM6Ly9zc28tbnAuZWJpei52ZXJpem9uLmNvbSIsImV4cCI6MTcyMDcxMDM1MCwidnp3QWNjb3VudE51bWJlciI6IjA3MjUzMjM5NDYwMDAwMDEiLCJpYXQiOjE3MjA3MDY3NTB9.iDnJSvRhDmZfC2OaF02NibbpS-zsrYoX-cpgl2w88nIhQVwPH-oT8StuuhW1AeJtFOj3mOif2wUhs8LN6JZB7Iu0tjhU_0kfiscN8D-hkToAWK4RBHTJo8f6bXRmRh2CdCrt4pvw3X44U4ADrI7zGF-jToyYkvqv7UHpGbVoLZRbjKud1YaMYsTePGDnIDdiGG31c7Tge_9nFPc6SqyaLXUvvU7OBkFJZVpeTRoYK5Di1HchVOqQdqiSlKs_OmYaj_vq0WS97Jej4WV2UWmJE4vzdy-bglLvTPgTtEcWWvu16pKTX-NthNLWbZlLrl-MsrHsdCUY5w4e17ZBNekfeg";
    request.headers["assisted_ig_session"] = sessionStorage.getItem("assisted_ig_session");
    request.headers["soeguisubkey"] = "4f8b8062-908a-41f6-bdd8-c9b3693b36ec";
    request.headers["soeguivalue"] = "eyJhbGciOiJSUzI1NiJ9.eyJyZWdObyI6IjUxIiwicmVwUm9sZSI6IlBPU0lUU1VQRVJVU0VSIiwicG9zVmVyc2lvbiI6IjIuMCIsImNoYW5uZWwiOiJPTU5JLVRFTEVTQUxFUyIsIm1hdmVyaWNrTG9jYXRpb24iOmZhbHNlLCJjcmVkaXRBcHBOdW0iOiI0MTYxMjg0OTkiLCJlbWFpbElkIjoiIiwiT1JERVJMT0MiOiIwMDI2MzAxIiwiSE9NRUxPQyI6IjAwMjYzMDEiLCJsb2dnZWRJblVzZXIiOiJ0YWJtZ3IiLCJpdnJMYW5ndWFnZSI6bnVsbCwiY3VzdG9tZXJUeXBlIjoiTiIsIm5ld1ByZVRvUG9zdEluZm8iOm51bGwsImRuaXMiOm51bGwsImFuaSI6bnVsbCwiaWF0IjoxNzIwNjg5NTY4LCJjYWxsUmVhc29uIjoiTmV3IENvbnN1bWVyIiwicmVwTGFzdE5hbWUiOiJNR1IiLCJjYWxsZXJNdG4iOm51bGwsIm10biI6IiIsImFxQ2FzZUlkIjpudWxsLCJyZXBGaXJzdE5hbWUiOiJUQUIiLCJhY2NvdW50TnVtYmVyIjoiIiwicmVwSWQiOiJFTkMxMyIsImlzSG9tZVNhbGVzIjoiZmFsc2UiLCJpdnJDYWxsZXJJZCI6bnVsbCwiYWNkQ2FsbElkIjpudWxsLCJvcmdpbmF0aW5nRG9tYWluIjpudWxsLCJyZWFzb25Gb3JWaXNpdCI6Ik5ldyBDb25zdW1lciIsInF1aWNrVmlldyI6eyJwZW5kaW5nT3JkZXJDb3VudCI6IjAiLCJlbGlnaWJsZUxpbmVDb3VudCI6IjAiLCJwYXN0RHVlIjoiMCIsImJ0YUFtb3VudCI6IjAiLCJkcEVsaWdpYmlsaXR5IjoiTm90IFZlcmlmaWVkIiwidG1wbWRFbGlnaWJsZSI6ZmFsc2UsInRhaEVsaWdpYmxlIjoiVEFIIEVsaWdpYmxlIn0sInZlcmlmaWVkTmFtZSI6InBhc3MgY3VzdG9tZXIiLCJob21lU2FsZXNBZGRyZXNzIjoiIn0.QAglILrlDUZyfCQmDzt7VQcfgTc1nz6t7LSZLBTmshIT_5WqYmHbUls7Za9ce5Cj45cbDShdmNlbZFdekOLIhqirklKCkB9jiGH3N1DpuF_XFa2EM1NAU32MqPM43ObxkPe-rV_vJMiS2e8JyVUMG-_dHnJ52DZQEnU1d45SlVw";
  }
  let nsasoeguisubkey =  sessionStorage.getItem("nsasoeguisubkey");
  let nsasoeguivalue =  sessionStorage.getItem("nsasoeguivalue");

  if(nsasoeguisubkey && nsasoeguivalue)
  {
    request.headers["soeguivalue"] = nsasoeguivalue;
    request.headers["soeguisubkey"] = nsasoeguisubkey;
  }
  
  return request;
});

HttpService.interceptors.response.use(response => {
  // Logic for the API console, needs to be refactored, should be in one method
  let urlPartitions = response && response.config && response.config.url ? response.config.url.split("/") : "";
  let e2erequestid = !sessionStorage.getItem("enableMock") ? response.headers["e2erequestid"] ? response.headers["e2erequestid"] : "" : "";
  if (urlPartitions) {
    let path = urlPartitions[urlPartitions.length - 2] || "";
    let endPoint = urlPartitions[urlPartitions.length - 1] || "";
    let status = response.status || "";

    let payload = {
      status: status,
      endPoint: endPoint,
      path: path,
      e2erequestid: e2erequestid
    };
    window.store.dispatch(apiConsoleActions.getApiConsoleData(payload));
    /** Adding Date to session to be used as client's time for preorder start time*/
    addDateToSession(response);
  }
  // ApiConsole logic end
  if (response.data && response.data.goToUrl !== undefined) {
    window.location.href = DOMPurify.sanitize(`${decodeURIComponent(response.data.goToUrl)}&TARGET=$SM$${window.location.href}`);
  }

  if (response && response.config && !kibana_regex.test(response.config.url)){
    Trace.traceSaveInteraction();
  }

  return response;
}, error => {
  // console.log("error at interceptors", error);
  // Logic for the API console, needs to be refactored, should be in one method
  let urlPartitions = error && error.config && error.config.url ? error.config.url.split("/") : "";
  let e2erequestid = error && error.response && error.response.headers["e2erequestid"] ? error.response.headers["e2erequestid"] : "";
  if (urlPartitions) {
    let path = urlPartitions[urlPartitions.length - 2] || "";
    let endPoint = urlPartitions[urlPartitions.length - 1] || "";
    let errorResp = error && error.response || "";
    let status = error && error.response && error.response.status ? error.response.status : "";

    let payload = {
      status: status,
      endPoint: endPoint,
      path: path,
      e2erequestid: e2erequestid,
      errorResp: errorResp
    };
    if (status === "" && e2erequestid === "" && endPoint !== "jsNotifyAsDynamic" && endPoint !== "loginV2") {
      logger.warningNetwork(payload);
    }
    window.store.dispatch(apiConsoleActions.getApiConsoleData(payload));
  }
  // ApiConsole logic end
  // Checking for errors, kibana url. Only the APIs, other than Kibana that has errors will be logged to kibana
  if (error && error.config && error.config.headers && !kibana_regex.test(error.config.url)) {
    error.config.headers.responseTimeStamp = Math.floor(Date.now());
    const responseDuration = error.config.headers.responseTimeStamp - error.config.headers.requestTimeStamp;
    logErrToKibana(error, responseDuration, e2erequestid);
  }

  if (error && error.config && !kibana_regex.test(error.config.url)){
    Trace.traceSaveInteraction();
  }

  window.store.dispatch(taggingActions.invokeTagging({
    pagename: taggingConstants.ERROR_REPORT,
    error
  }));

  throw error;
});


const enableHTTPServiceLogs = sessionStorage.getItem("enableHTTPServiceLogs") || false;

export function parseErrorMessages(error) {
  let messages;
  //temporary : removing JS errors changes because its causing empty green banner messages on multiple pages.
  //  Please check empty green banner condition while getting rid of JS Errors
  const jsErrors = has(error, "message") ? [error.message] : [];
  const apiErrors = has(error, "response.data.errors") ? error.response.data.errors : [];

  //const errorList = jsErrors.concat(apiErrors);
  const errorList = apiErrors;

  enableHTTPServiceLogs && console.log("LOG-DEBUG: parseErrorMessages -> errorList", errorList);
  if (error && !isEmpty(errorList)) {
    const isRfexFlow = sessionStorage.getItem("refundexchange");
    if(isRfexFlow){
      messages = errorList.map(error => {
        if(error.id && ERROR[error.id]){
          if(error.id === "3217" && error.message.includes('Error msg from lineValidationOrderService:')){
            let newMsg = error.message.replace('Error msg from lineValidationOrderService:' ,'');
            newMsg = newMsg.replace('PP','BC');
            return newMsg;
          }
          return ERROR[error.id];
        }else if(error.message){
          if(error.name === "BLIND_INVALID_MTN"){
            return null;
          }
          return error.message;
        }else{
          return error;
        }
      }).join("<br />");
    }else{
       messages = errorList.map(error => {
        if(!error.message
          && error?.details?.[0]?.issue){
          error.message=error.details[0].issue;
        } else if (!error.message) {
          error.message="Something went wrong, please try again.";
        }
        return error.message ? error.message : error }).join("<br />");
    }    
  }
  enableHTTPServiceLogs && console.log("LOG-DEBUG: parseErrorMessages -> messages", messages);
  return messages;
}
export function logErrToKibana(error, responseDuration = 0, e2erequestid) {
  const { data } = error && error.response ? error.response : {};
  const { errors } = error && error.response && error.response.data ? error.response.data : [];
  //let serverDuration = responseDuration;
  //let networkDuration = responseDuration;
  if (errors && errors.length > 0 &&
        !(Object.entries(data.errors[0]).length === 0 &&
            data.errors[0].constructor === Object)) {
    const log =
        {
            messageType: "ERROR",
            eventType: "FeError",
            subEventType: "FeErrorS",
            pageUrl: window.location.href,
            serviceUrl: error && error.config && error.config.url? error.config.url :'',
            method: error.config.method,
            errorMessage: errors[0].message,
            cookie: getVisitorId(),
            e2erequestid: e2erequestid ? e2erequestid : "",
            loggerMessage:
            {
              message: errors[0].message,
              loglevel: errors[0].severity,
              //serverDuration: error.duration ? error.duration : 0,
              responseDuration: responseDuration,
              //networkDuration: networkDuration,
              userAgent: navigator.userAgent,
              pageTitle: document.title,
              host: window.location.host,
              stackTrace: error.stack
            }
        };
    kibanaLogger(log);
  }
}
/**
 * Base method which is called for all API calls.
 * @param {String} method Request Method ( GET|POST|PUT etc )
 * @param {String} url Request URL
 * @param {Object} [request] Request body for the API call
 * @param {Function} [successCallback] Success callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Function} [errorCallback] Error callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Object} [opts] Additional options for configuring the request
 *                      - showLoading -> default: true => Determines if loading shown before and after the request
 *                      - parseResponse -> default: false => Determines if response should be extracted from resp.payload.data
 *                      - showErrorBanner -> default: true => Determines if an app message with the API error should be displayed
 *                      - timeout -> default: 60000ms => Determines after what time the API returns a failure
 *                      - baseURL -> default: empty => Allows customization of the baseURL
 *                      - closeLoadingOnSuccess -> default: false => Stops the loading once success response is done. Wont wait for events inside successHandle to be completed
 */
function* doApiCall(method, url, request, successCallback, errorCallback, opts = {}) {
  enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> method", method);
  enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> url", url);
  const { showLoading = true, parseResponse = false, showErrorBanner = true, timeout = 60000, baseURL, closeLoadingOnSuccess = false, headers, withCredentials, appMessageWithTimer = true } = opts;


  const axiosOptions = { baseURL, timeout, headers, withCredentials };
  try {
    if (showLoading) yield put(appLoaderActions.show());
    let res;
    switch (method) {
      case "GET":
        res = yield call(() => HttpService.get(url, axiosOptions), null);
        break;
      case "POST":
        res = yield call(() => HttpService.post(url, request, axiosOptions), null);
        break;
      case "PUT":
      case "DELETE":
      case "PATCH":
      case "HEAD":
        // TODO: Implement if needed
        break;
      default:
        console.warn("LOG-DEBUG: function*doApiCall -> Incorrect use of doApiCall");
        break;
    }
    const response = parseResponse ? res.data.payload : res;
    enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> response", url, response);
    if (closeLoadingOnSuccess) yield put(appLoaderActions.hide());
    if (successCallback) yield successCallback(response);
  } catch (error) {
    // logErrToKibana(error);
    enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> error", url, error);
    if (closeLoadingOnSuccess) yield put(appLoaderActions.hide());
    if (showErrorBanner && parseErrorMessages(error)) yield put(appMessageActions.addAppMessage(parseErrorMessages(error), "error",true,appMessageWithTimer,true));
    if (errorCallback) yield errorCallback(error);
  } finally {
    enableHTTPServiceLogs && console.log("LOG-DEBUG: function*doApiCall -> finally", url);
    if (showLoading && !closeLoadingOnSuccess) yield put(appLoaderActions.hide());
  }
}

/**
 * Wrapper method for making GET calls
 * @param {String} url Request URL
 * @param {Function} [successCallback] Success callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Function} [errorCallback] Error callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Object} [opts] Additional options for configuring the request
 *                      - showLoading -> default: true => Determines if loading shown before and after the request
 *                      - parseResponse -> default: false => Determines if response should be extracted from resp.payload.data
 *                      - showErrorBanner -> default: true => Determines if an app message with the API error should be displayed
 *                      - timeout -> default: 60000ms => Determines after what time the API returns a failure
 *                      - baseURL -> default: empty => Allows customization of the baseURL
 */
export function* doGet(url, successCallback, errorCallback, opts) {
  yield doApiCall("GET", url, null, successCallback, errorCallback, opts);
}

/**
 * Wrapper method for making POST calls
 * @param {String} url Request URL
 * @param {Object} request Request body for the API call
 * @param {Function} [successCallback] Success callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Function} [errorCallback] Error callback function that can call one or more actions
 *                      - Should be a generator function
 * @param {Object} [opts] Additional options for configuring the request
 *                      - showLoading -> default: true => Determines if loading shown before and after the request
 *                      - parseResponse -> default: false => Determines if response should be extracted from resp.payload.data
 *                      - showErrorBanner -> default: true => Determines if an app message with the API error should be displayed
 *                      - timeout -> default: 60000ms => Determines after what time the API returns a failure
 *                      - baseURL -> default: empty => Allows customization of the baseURL
 */
export function* doPost(url, request, successCallback, errorCallback, opts = {}) {
  if (request !== null && request != "" && typeof(request) === "object") {
    yield doApiCall("POST", url, request, successCallback, errorCallback, opts);
  }else{
    console.warn("LOG-DEBUG: function*doApiCall -> request payload is invalid");
    yield put(appMessageActions.addAppMessage("invalid request","error",true,true,true));    
  }  
}


export class AxiosCancelToken {
  constructor() {
    this.cancelTokensList = new Map();
  }

  create(key) {
    return {
      cancelToken: new axios.CancelToken(c => this.cancelTokensList.set(key, c))
    };
  }

  cancel(key, reason) {
    let token = this.cancelTokensList.get(key);
    token && token(reason);
  }

  cancelAll() {
    [...this.cancelTokensList].forEach(([key, token]) => token && token());
  }
}
